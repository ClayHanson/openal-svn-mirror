= Contents =

- Building OpenAL with autotools
- Building OpenAL with CMake


= Building OpenAL with autotools =

If this is your first time retrieving CVS, you will need to build the
configure script and config.h.in dependency.  Just run

	sh ./autogen.sh

and you should be okay.

Compilation / installation goes something like this:

	./configure --prefix=/usr/local
	make
	cd test
	[run tests]
	make install

If you are on x86(_64) if may be wise to send your CFLAGS along to
configure, as dependening on them, SIMD code will be activated, ie:

	CFLAGS="-march=athlon-xp" ./configure --prefix=/usr/local

configure will detect that "-march=athlon-xp" activates MMX, SSE,
3dNOW!, SSE-MMX and 3dNOW! extended. You can also explicitly enable a
specific SIMD instruction set via CFLAGS, ie -mmmx activates MMX on the
GCC compiler. Refer to its manual. Currently OpenAL only features some
MMX code though, so other SIMD instruction set are ignored.
On x86 (32 bit) it is advised to have nasm installed. Then it is safe
to activate all SIMD instruction sets at compile time, as at runtime the
detection will only activate supported SIMD routines.
(Above example shouldn't be used as such though, as it doesn't do any
optimization, so send more flags and/or use the optimization configure
option.)


configure options:
	--enable-debug        Enable debugging info.
	--enable-optimization Enables optimization.

etc...  Use --help to determine the rest.  Most people will be fine with
--enable-optimization.

Debugging options are now in the form:

	--enable-debug-blah

in general, this will give you too much information to be useful on a
particular topic.  Use --enable-debug-maximus to get all debugging
messages possible.

If this is your first time installing openal, you'll probably need to
run ldconfig.

ATTENTION:

The following changes have taken place that may alter the manner in
which an installation works on your machine.  Please be advised:

	- SDL is no longer required to build --- the conversion code
	  has been copied into the audioconvert directory.

If you experience any problems building or with the test code, please
email me: jvalenzu@linuxgames.com.  Thanks.

jv.


= Building OpenAL with CMake =

The CMake build files are maintained by prakash@punnoor.de, so
if you have troubles building OpenAL using CMake, please contact
me and not the OpenAL devs, as the official build system is still
the one using autoconf/make. The CMake build files are currenty
meant as an additional possibility to build OpenAL.

The aim of using CMake is making portable development easier, as
CMake containg generators for various build systems. On eg. Unix
Makefiles will be built, and on Windows MS VC++ project files, if
you wish. You can get CMake at cmake.org.

Current status:
The build system is feature complete, so it (should) build every-
thing as the (old) default one has done.

(+,o,- indicates feature more/same/less then default OpenAL
build system.)

o builds shared OpenAL lib
o builds static OpenAL lib; can be deactivated
o builds the test-suite, if specified
o all backends and vorbis/mp3/SDL support should be handled by CMake

+ out of tree builds are supported
+ correct dependency tracking of source files
+ prepared for adding support for non GNU compiler
  (setting link libraries probably needs cleaning up)

- only native, alsa backends and vorbis support compile tested yet
  (so please report back if it works for you! :-)


This document explains briefly how to build with CMake on Linux via out-
of-tree build:

- Change to the linux dir.
- Create a dir, eg "default", and change into it.
- Now (eg.) run:

cmake .. -DCMAKE_INSTALL_PREFIX:STRING="/usr" -DCMAKE_C_FLAGS:STRING="-march=athlon-xp -O2"
make
make install

  If you exported your CFLAGS, there is no need to specify them
  explicitly, as CMake will pick them up.

- OpenAL should get installed as you got used to it.


I really would like to get CMake building OpenAL on every
supported platform. So please contact me if it doesn't build
on yours. I'll try to fix this with your help.


Some Tips:

- You can use a console GUI named ccmake for configuring cmake.
  This also comes in handy, to find out about available options.
  You can also set options via command-line:

ccmake .. -DCMAKE_INSTALL_PREFIX:STRING="/usr" -DCMAKE_C_FLAGS:STRING="-march=athlon-xp -O2"

  sets the two variables defined on command line and then starts
  the GUI. Press 'c' the first time and every time you want to commit
  changes in the config. Finally press 'g' to run the generator.
  Btw, to set boolean vars from the command line, use -DVAR:BOOL=X,
  where X is eg. ON or OFF.

- If you want more output at compile time, use

make VERBOSE=1

- If you want to install to a different directory (using same prefix),
  use

make install DESTDIR=/foo/bar

- CMake doesn't has a distclean target by default, so you better
  really do an out-of-tree build, then you can simply delete its
  content when you want a distclean... Furthermore it is easier to
  have different builds using different parameters via out-of-tree
  builds.

- If you are interested in variables to set, take a look into
  CMakeCache.txt after having run the configuring stage.

- If you update your source tree via cvs and want to rebuild an pre-
  viously built lib without cleaning, you better at least clear the 
  CMake cache (remove CMakeCache.txt) otherwise a modified CMake project
  file could result to unwanted behaviour.


Cheers,

Prakash

================================================================================

Some notes about the "darwin" backend:

Q : How can I choose the sound card I want for rendering?
A : You can't. The first found is the first used.

Q : MP3 support doesn't work.
A : To enable MP3 exentensions, SDL must be installed. Maybe it works, maybe
not. I don't have nor time neither SDL to test.

Q : The compiler complains about lack of libdl.
A : libdl.dylib is required. You must install it before compiling.

Q : Moving windows or using a big amount of CPU power makes result sound choppy.
A : Increase the number of buffers in "darwin_native.c" and recompile.

Q : There's really too much latency.
A : Decrease the number of buffers in "darwin_native.c" and recompile.

Q : There's really too much latency and result sound choppy.
A : Change your CPU or write a better MOSX implementation than mine !

Q : Why my question is not listed here?
A : Because I can't guess ALL questions ! Ask me directly : gborios@free.fr

----------

Version : Alpha 6
Better bridge between CoreAudio and OpenAL :
=> No choppy sound anymore.
=> Minimum latency.
=> CPU load greatly lowered.
Should work better with different contexts modes (Sample rates, Mono/stereo,
8/16bits), to be tested...

Version : Alpha 5
Support for MOSX 10.1
Better sound buffer copying stuff.
Corrected a bug that caused regular bus errors.

Version : Alpha 3 & 4
Test versions for Garin and me under MOSX Public Beta and 10.0

Version : Alpha 2
Modified buffering system to use n buffers => sounds less choppy when CPU gets
suddenly loaded.
Implemented :
    * void  release_native(),
    * void pause_nativedevice(),
    * void resume_nativedevice().

Version : Alpha 1
First version to play sound !
Implemented :
    * void *grab_write_native(),
    * ALboolean set_write_native(),
    * void  native_blitbuffer().

----------

ToDo:

Implements what's not !
Add a preference file to determine which is the default Audio Controller (by now, it is the first found).
Optimize for Altivec.
Clean up everything.
Try to make all test programs work.


----------

This is the results of the test programs compiled with alpha 5 version of the
MOSX Backend and the default branch of the OpenAL CVS. I didn't have time to
check deeply each example, but I did it for some.

OK : 31
OK but... : 5
Can't test : 6
FAIL : 11

testalinitexit	OK
testalut	OK
testbufferuniq	OK
testcallback	Can't test (Don't have the test file : "adpcm.adp")
testcapture	Can't test (void *grab_read_native() is not implemented under MOSX).
testchannel	FAIL : Start OK but sound stops quickly (at the 15th iteration actually)
testchannel2	Can't test (int set_nativechannel() & float get_nativechannel() are not implemented under MOSX).
testda	OK
testdevice	OK
testdoppler	OK but can't hear any doppler effect...
testext	OK
testgain	OK
testgainlinear	OK
testgendelbuffer_error	OK
testgendelsource_error	OK
testleak	Can't test (Don't have the test file : "adpcm.adp")
testleak2	Can't test (Don't have the test file : "adpcm.adp")
testlistener	OK
testlistener2	OK
testlistener3	OK but can't hear angle modifications...
testlistener4	OK but can't hear angle modifications...
testloop	see problem #1 
testmath	OK, at least I think.
testmp3	FAIL : Could not GetProc alutLoadMP3_LOKI
testmp32	FAIL : Could not GetProc alutLoadMP3_LOKI
testmulti	OK
testmultialut	OK
testmultichannel	OK
testmulticontext	OK
testmulticontext2	OK
testmultimp3	FAIL : Could not GetProc alutLoadMP3_LOKI
testmultinothread	OK, but sounds very bad at the beginning (expected behaviour under MOSX)
testnothread	OK
testorient	OK
testpause	OK
testpitch	OK
testpitch2	FAIL : No sound
testpitch3	OK -> with problem #2 and modif #1
testpitch4	FAIL : No sound
testpitchnothread	OK
testpitchnothread2	OK
testqueue	FAIL ? Over appears before end of source
testqueue2	FAIL ? Over appears before end of source
testqueue3	FAIL ? Over appears before end of source
testrelative	OK, but sound doesn't seem to move
testreverb	OK, but must make 10^5 more micro_sleep to hear sound. Makes me think micro_sleep is broken.
testsingle	OK -> with problem #2 and modif #1
testsourcestop	OK
testsourceuniq	OK
teststartstop	OK
teststream	Can't test (Don't have the test file : "rawpcm.pcm")
teststrings	OK
testtime	FAIL ? Over appears before end of source
testvorbis	FAIL : Could not GetProc alutLoadVorbis_LOKI


Problems :

#1 : It seems something goes wrong with AL_LOOPING. in testloop : after
alSourceStop() AL_LOOPING is set to false even before we explicitely set
it. then we set it to false in the test app, and asking for the loop state is OK
(returns false). then we call alSourcePlay() and ask again for the looping state
: it has been now strangely reseted to true. The solution is to change the
looping value whiel the source is still playing, but is this a normal behaviour? 
I guess no.

#2 : when a mixer source is destroyed, the bid_queue.read_index of the attached
source is set to the size of the bid_queue. So when reallocating a new mix
source for the same source, the bid is invalid because bid queue read index is
out of range (1buffer too far). See modif #1 for a solution.

Modifications :

#1 : al_mixer.c, line 719 : mixer modif when reallocating for a stopped source
-> I guess this is the modif Joe made Monday.

================================================================================

Some notes about the "native" backend on IRIX:

Maintainer: Erik Hofman <erik@ehofman.com>

The following configuration options could be specified
in the ~/.openalrc file:

1. You can now define up to four output channels.
2. You can specify which output port or interface to use.
3. For systems that don't support 4 channel audio natively
   you can specify a second device that is used for the rear
   channels.

A typical O2 configuration file would look like this:

(define speaker-num 4)
(define native-out-device "Analog Out")
(define native-rear-out-device "Analog Out 2")

or alternatively:

(define speaker-num 4)
(define native-out-device "A3.Speaker")
(define native-rear-out-device "A3.LineOut2")

================================================================================
